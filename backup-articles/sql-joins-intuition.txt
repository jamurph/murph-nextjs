I don't think SQL Joins are very well understood by the typical web developer.

Some of the saddest, most brilliantly horrible lines of code I've ever witnessed have been SQL queries using subqueries where joins were needed.

This needs to stop. SQL Joins are not complicated. Here's the intuition for them.

## What's in a query?

Every query is simply a specification for gathering data.

If you were in charge of gathering some data, the first question you ought ask is "Where should I look?".

This is the entire purpose of the SQL FROM clause. It's a specification of where the right data might be found.

Usually, this is quite simple:

```
FROM users
```

In this case, we're just looking in one place. Namely, the users table.

However, what if the data is split across tables? This is where joins come in.

## Conceptual Anatomy of A Join

Tables are essentially 2-dimensional arrays like a grid or excel spreadsheet. The purpose of a SQL Join is to bring these two arrays together.

After a join, you want to have one grid with the columns of both of the initial tables.

If we were writing code to pull together data in multiple 2D arrays, it might look something like this:

```
table_one = [ [1], [2], [3] ]
table_two = [ [4], [5], [6] ]

result = []

foreach(t1_row in table_one){
   foreach(t2_row in table_two){
      result.append( t1_row.concat(t2_row) )
   } 
}

# result = [ [1,4], [1,5], [1,6], [2,4], [2,5], [2,6], [3,4], [3,5], [3,6] ]
```

As you can see, it returns every possible combination of rows from the two tables together. Since we started with 3 rows in each table, we end up with a total of 9 rows in the result. In SQL, this brute is known as a CROSS JOIN.

Normally, we wouldn't want every combination of rows. Maybe we should limit it based on a condition:

```
table_one = [ [1], [2], [3] ]
table_two = [ [4], [5], [6] ]

result = []

foreach(t1_row in table_one){
   foreach(t2_row in table_two){
      if( #CONDITION# ) {
         result.append( t1_row.concat(t2_row) )
      }
   } 
}

# For example, if the condition was t2_row.contains(5), then result = [ [2,5] ]
```

Now this will give us only those results that matched the condition. In SQL, this is known as an INNER JOIN.

What if we always wanted to keep items in the first table, but include items from the second based on the condition?

```
table_one = [ [1], [2], [3] ]
table_two = [ [4], [5], [6] ]

result = []

foreach(t1_row in table_one){
   foreach(t2_row in table_two){
      if( #CONDITION# ) {
         result.append( t1_row.concat(t2_row) )
      } else {
         result.append( t1_row )
      }
   } 
}

# For example, if the condition was t2_row.contains(5), then result = [ [1], [2,5], [3] ]
```

This is known as a LEFT OUTER JOIN.

To get what is known as a RIGHT OUTER JOIN, switch the for loops order and append t2_row in the else statement, instead. Typically RIGHT OUTER joins aren't used. It is usually easier to think of things from a LEFT OUTER perspective. They are essentially the same.

The final join type is FULL OUTER. FULL OUTER joins bring together and include any 2 rows matching the condition, but still include ones that do not match any.

You can also think of a full outer join as the result of a LEFT OUTER + RIGHT OUTER - INNER. Both the LEFT OUTER and RIGHT OUTER contain what would be the results of an INNER join, so we must subtract one INNER.

## No Waste

Subqueries in lieu of joins are needless waste. Many optimizations for queries will occur in the Joins or by using a better joining strategy.

While the actual implementation of joins on a SQL server might be way more complicated than any of the above code would indicate, the basic intuition can go a long way to helping you use joins more effectively in your queries.